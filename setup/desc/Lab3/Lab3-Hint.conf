Рекомендации к выполнению:
systemd — подсистема инициализации и управления службами в Linux. 
Основополагающая цель системы инициализации заключается в инициализации компонентов, которые должны запускаться после загрузки ядра Linux (традиционно называются компоненты пользовательского пространства).
Основная особенность — интенсивное распараллеливание запуска служб в процессе загрузки системы, что позволяет существенно ускорить запуск операционной системы. Основная единица управления — модуль (юнит), одним из типов модулей являются «службы» (модули типа .service) — аналог демонов — наборы процессов, запускаемые и управляемые средствами подсистемы и изолируемые контрольными группами.
Системные юниты systemd находятся в каталоге /etc/systemd/system.
Служба в systemd описывается файлом юнита, в нем описано что с ней нужно делать и как себя вести. Существуют такие типы служб:
service - обычная служба, программа;
target - группа служб;
automount - точка автоматического монтирования;
device - файл устройства, генерируется на этапе загрузки;
mount - точка монтирования;
path - файл или папка;
scope - процесс;
slice - группа системных служб systemd;
snapshot - сохраненное состояние запущенных служб;
socket - сокет для взаимодействия между процессами.
Для управления systemd используется утилита systemctl. Основной синтаксис утилиты: systemctl <commnad> <module>. То есть после имени утилиты указывается команда и модуль, к которому данную команду необходимо применить.
По умолчанию если указывать в команде название модуля без его типа, то команда будет выполнена к модулю типа .service.
При создании новых модулей необходимо обновлять систему с помощью команды:
    systemctl daemon-reload
1.  Работа со службами
1.1 Запуск и остановка служб
Чтобы запустить службу systemd, используйте команду start с именем необходимой службы. Пример:
    systemctl start application.service 
Чтобы остановить службу, используйте команду stop. Пример:
    systemctl stop application.service
1.2 Перезапуск и перезагрузка
Чтобы перезапустить работающую службу, можно использовать команду restart с именем службы.
Если данное приложение может перезагрузить файлы конфигурации (без перезапуска), вы можете выдать команду reload для инициализации этого процесса.
1.3 Включение и отключение служб
Важно понимать то, что службы могут быть включены и отключены. Если служба включена, она будет запускаться автоматически при загрузке операционной системы.
Для запуска службы во время загрузки используйте команду enable.
Чтобы отключить автоматический запуск службы, используйте команду disable.
1.4 Проверка статуса служб.
Чтобы проверить статус службы в вашей системе, можно использовать команду status.
При этом вы получите статус службы, иерархию контрольных групп и первые несколько строк журнала.
Также есть методы для проверки определенных статусов. Например, чтобы проверить, активен ли (работает ли) модуль в данный момент, можно использовать команду is-active.
Чтобы увидеть, включен ли модуль, можно использовать команду is-enabled.
Третья проверка заключается в проверке того, находится ли модуль в состоянии сбоя. Это означает, что была проблема, которая запустила данный модуль
2. Обзор работы всей системы
Чтобы увидеть список всех активных модулей, о которых знает systemd, можно использовать команду list-units:
    systemctl list-units
Вывод содержит следующие столбцы:
UNIT: имя модуля systemd
LOAD: указывает на то, парсила ли systemd конфигурацию модуля. Конфигурация загруженных модулей сохраняется в памяти.
ACTIVE: краткое состояние активности модуля. Обычно это довольно стандартный способ сообщить, запущен модуль или нет.
SUB: это состояние более низкого уровня, которое указывает более подробную информацию о модуле. Это часто зависит от типа модуля, состояния и фактического метода работы модуля.
DESCRIPTION: краткое текстовое описание того, чем является модуль/что делает.
Можно использовать systemctl для вывода различной информации путем добавления дополнительных флагов. Например, чтобы увидеть все модули, которые загрузила система systemd (или пыталась загрузить), независимо от их активности в данный момент, можно использовать следующий флаг --all:
    systemctl list-units --all
Другим распространенным флагом является фильтр ---type=. Мы можем задать systemctl только для отображения модулей интересующего нас типа. Например, чтобы увидеть только активные модули службы, мы можем:
    systemctl list-units --type=service
3. Создание своих модулей (юнитов).
Структура systemd Unit файлов
Внутренняя структура файлов организована с помощью разделов. Разделы обозначаются двумя квадратными скобками «[» и «]» с именем раздела, заключенного внутри. Каждый раздел продолжается до начала следующего раздела или до конца файла.
Названия разделов хорошо определены и учитывают регистр. Таким образом, раздел [Unit] не будет интерпретироваться правильно, если он записан как [UNIT].
Рассмотрим основные разделы:
    [Unit]
Первый раздел, найденный в большинстве юнит-файлов, — это раздел [Unit]. Обычно его используют для определения метаданных устройства и настройки отношения устройства к другим устройствам.
Хотя порядок разделов не имеет значения для systemd при парсинге файла, этот раздел часто размещается сверху, потому что он предоставляет обзор устройства. Некоторые общие директивы, которые вы найдете в разделе [Unit]:
Description=: Эта директива может использоваться для описания имени и основных функций устройства. Он возвращается различными инструментами systemd, поэтому полезно установить что-то короткое, конкретное и информативное.
BindsTo=: Эта директива аналогична Requires =, но также приводит к остановке текущего устройства, когда соответствующий узел завершается.
Before=: Юниты, перечисленные в этой директиве, не будут запущены до тех пор, пока текущий блок не будет отмечен как запущенный, если они будут активированы одновременно.
After=: Юниты, перечисленные в этой директиве, будут запущены до запуска текущего устройства (юнита).
Conflicts=: Данный юнит можно использовать для отображения юнитов, которые нельзя запускать одновременно с текущим устройством. Запуск устройства с этой связью приведет к остановке других устройств.
Condition…=: Существует ряд директив, начинающихся с условия, которые позволяют администратору протестировать определенные условия до запуска устройства. Это можно использовать для предоставления файла универсального элемента, который будет запускаться только в соответствующих системах. Если условие не выполнено, юнит — пропускается.
Используя эти директивы и несколько других, можно установить общую информацию об устройстве и его взаимосвязь в операционной системой.
    [Install]
В самом конце файла, расположен — [Install] секция. Этот раздел является дополнительным и используется для определения поведения или юнита, если он включен или отключен. Включение устройства означает, что он автоматически запускается при загрузке. По сути, это достигается путем фиксации рассматриваемого устройства на другом блоке, который находится где-то в строке единиц, которые нужно запустить при загрузке.
Из-за этого, только юниты, которые могут быть включены, будут иметь этот раздел. Директивы внутри, говорят что должно произойти, когда устройство включено:
WantedBy=: Данная директива, является наиболее распространенным способом определения того, как устройство должно быть включено. Эта директива позволяет вам указать зависимость ( аналогично директиве Wants = в разделе [Unit]).
RequiredBy=: Эта директива очень похожа на директиву WantedBy =, но вместо этого указывает требуемую зависимость, которая приведет к сбою активации, если не будет выполнена. Когда включено, юнит с этой директивой создаст каталог, заканчивающийся на .requires.
    [Service]
Раздел [Service] используется для предоставления конфигурации, которая применима только для служб.
Для данного раздела имеются следующие директивы:
ExecStart=: Нужно указать полный путь и аргументы команды, которая должна быть выполнена для запуска процесса. Это может быть указано только один раз (кроме сервисов «onehot»). Если для пути к команде предшествует символ «-» тире, будут приняты ненулевые статусы выхода без маркировки активации устройства как сбой.
ExecStartPre=:Нужно указать полный путь и аргументы команды, которые должны быть выполнены до запуска основного процесса. Это можно использовать несколько раз.
ExecStartPost=: Это имеет те же самые качества, что и ExecStartPre = за исключением того, что данная дириктива указывает команды, которые будут запускаться после запуска основного процесса.
ExecReload=: Эта необязательная директива указывает команду, необходимую для перезагрузки конфигурации службы, если она доступна.
ExecStop=: Это указывает на команду, необходимую для остановки службы. Если это не указано, процесс будет немедленно уничтожен, когда служба будет остановлена.
    [Path]
Блок path, определяет путь файловой системы, который systmed может отслеживать изменения. Должен существовать другой блок, который будет активирован, когда определенная активность будет обнаружена в местоположении пути. Активность пути определяется тем, что он не влияет на события.
Раздел [Path] может содержать следующие директивы:
PathExists=: Эта директива используется для проверки того, существует ли этот путь. Если путь существует, активируется соответствующий блок.
PathExistsGlob=: Данная опция такая как и выше, но поддерживает глобальные выражения для определения существования пути.
PathChanged=: Данную опцию используют для отслеживания изменений местоположение пути. Связанный блок активируется, если обнаружено изменение (проверяется когда файл закрыт).
PathModified=: Данная опция такая как и выше, но активируется при записи файлов, а также когда файл закрыт.
ВАЖНО!!! Чтобы модуль .path запускал службу .service, необходимо дать им одинаковые имена, либо указать это явно в директивах. Для простоты в данной работе используйте одинаковые имена. То есть, чтобы модуль abc.path запустил службу, назовите её abc.service.
    [Timer]
Timer юнит,  используются для планирования задач для работы в определенное время или после определенной задержки. Этот тип устройства заменяет или дополняет некоторые функции cron-а и демонов. Должен быть предоставлен соответствующий блок, который будет активирован, когда таймер будет достигнут.
Раздел [Timer] может содержать некоторые из следующих директив:
OnActiveSec=: Эта директива позволяет активировать соответствующий блок относительно активации модуля .timer.
OnBootSec=: Эта директива задает время, когда будет активироваться соответствующее  устройство после загрузки системы.
OnStartupSec=: Эта директива аналогична указанному выше таймеру, но задает когда будет активироваться systemd процесс после загрузки системы.
OnUnitActiveSec=: Это устанавливает таймер в зависимости от того, когда последний активировался.
OnUnitInactiveSec=: Это устанавливает таймер в отношении того когда unit был неактивный.
OnCalendar=: Это позволяет активировать соответствующий блок путем определения абсолютного (вместо относительно). Для данной директивы возможно использование шаблонов. Например, для того, чтобы модуль срабатывал каждые 10 секунд можно использовать: OnCalendar=*:*:0/10.
ВАЖНО!!! Модуль .path аналогично запускает службу с таким же именем.
В результате в службе могут быть три раздела: [Unit], [Install] и раздел совпадающий по имени с типом службы.
Порядок создания службы:
    1. Создание соответствующих юнитов в /etc/systemd/system
    2. Перезагрузка системы systemd командой: systemctl daemon-reload
    3. Запуск юнитов командой: systemctl start
Для более подробного изучения systemd можно обратиться к Интернет-ресурсам.

